> Για την επίλυση της άσκησης 1: **Fauxtoshop** 

* Φτιαχνω τη συνάρτηση **isValid** η οποία ελέγχει αν η εικόνα απο το stdin είναι έγκυρη(ειναι BMP εικόνα)

* Έπειτα τη συνάρτηση **rotateBMP90degrees**, η οποία δέχεται 2 αρχεία ως όρισμα(τα οποία θα προέλθουν από το stdin):
    * Ορίζει έναν πίνακα 54 θέσεων για το ελάχιστο μέγεθος του header
    * "Διαβάζει" τα πρώτα 54 στοιχεία του αρχείου από το stdin με τη χρήση της fread(). Διαβάζει σημαντικά στοιχεία απο τη κεφαλίδα:

    ```uint32_t width = *(uint32_t*)&minheader[18];```

    ```uint32_t height = *(uint32_t*)&minheader[22];```

    ```uint16_t BitsPerPixel= *(uint16_t*)&minheader[28];```

    ```uint32_t headersize = *(uint32_t*)&minheader[10];```


    * Το 18ο byte της κεφαλίδας (18 - 22) περιέχει το πλάτος της εικόνας άρα αφορά 4*8 = 32 bits αναπαράσταση του πλάτους.
    * Το 22ο byte της κεφαλίδας (22 - 26) περιέχει το ύψος της εικόνας άρα αφορά 4*8 = 32 bits αναπαράσταση του ύψους.
    * Το 28ο byte της κεφαλίδας (28 - 29) περιέχει τον αριθμό των bits ανά pixels της εικόνας άρα αφορά 2*8 = 16 bits αναπαράσταση.
    * Το 10ο byte της κεφαλίδας (10 - 14) περιέχει το πραγματικό μέγεθος της κεφαλίδας(το offset) αρα αφορά 4*8 = 32 bits για την αναπαράσταση 

    - Η έκφραση (*(uint32_t*)&header[18];):  
        * Το ```&header[18]```  παίρνει τη διεύθυνση της μνήμης του 18 στοιχείου του πίνακα header.
        * Το ```(uint32_t*)``` κάνει cast τη διευθυνση μνήμης του 18ου στοιχείου του πίνακα απο δεικτη σε uint8_t σε δεικτη σε uint32_t.
        * To ```*``` στην αρχή παραπέμπει στο δείκτη που λαμβάνεται μετα το cast. Παίνει την τιμή που είναι αποθηκευμένη στη θέση μνήμης που δείχνει η διεύθυνση που υπολογίζεται ερμηνεύοντας το &header[18] ως uint32_t*. Αυτό σημαίνει ότι ερμηνεύει τα 4 byte ξεκινώντας από το 18ο byte στον πίνακα κεφαλίδων ως μια ακέραια τιμή.
        * (ομοίως για τα άλλα 2 με τη μόνη διαφορά το uint16_t στο 3ο)

    * Καλείται η συνάρτηση isValid.
    * Δημιουργείται νέος πίνακας header και διαβάζονται τυχόν καινούργια στοιχεία, πέρα απο τα 54
    * Υπολογίζεται το μέγεθος της εικόνας λαμβάνοντας υπόψη το padding ως εξής: 

        * Η έκφραση ```((width * 3 + 3) / 4) * 4;``` 
            * ```width * 3``` : Υπολογίζει τα bytes που χρειάζονται για μια σειρά από pixels της εικόνας  μιας και κάθε pixel αποτελείται απο 3 bytes (ενα για κάθε χρώμα απο τα Red, Green, Blue).
            * ```width * 3 + 3```: Προσθέτοντας 3 στο σύνολο των bytes λαμβάνουμε υπόψη πιθανό padding. Αυτο εξασφαλίζει οτι η επόμενη ακέραια διαίρεση θα οδηγήσει στο επόμενο πολλαπλάσιο του 4
            * ```(width * 3 + 3) / 4```: Με τη διαίρεση(που είναι ακέραια) υπολογίζεται το μέγεθος που χρειάζεται για κάθε γραμμη λαμβάνοντας υποψη το πιθανο padding.
            * ```((width * 3 + 3) / 4) * 4```: Τελικά ο πολλαπλασιασμός με το 4 υπολογίζει το μέγεθος κάθε σειρας σε bytes και μεχρι τωρα έχει εξασφαλιστεί οτι θα είναι πολλαπλάσιο του 4.

    * Δημιουργείται ο πίνακας pixels που θα αποθηκεύσει τα pixels της εικόνας. Ορίζεται το νέο υψος, πλάτος και μέγεθος της ανεστραμμένης εικόνας και γίνεται η περιστροφή με τη χρήση 2 for loops.(Κάθε pixel της εικόνας αναπαριστάται απο 3 θέσεις στον πίνακα, μία για κάθε ένα απο τα 3 χρώματα RGB).
    * Mεταφέρονται τα νέα δεδομένα(header, pixels) στο καινούργιο αρχείο.

* Στη main καλείται η συνάρτηση για περιστροφή της εικόνας με ορίσματα: stdin, stdout, γιατι από εκεί δέχεται το πρόγραμμα τα αρχεία με ανακατεύθυνση.
