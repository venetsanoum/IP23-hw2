> Για την επίλυση της άσκησης 1: **Fauxtoshop** 

* Φτιαχνω τη συνάρτηση **isValidBMP** η οποία ελέγχει αν η εικόνα απο το stdin είναι έγκυρη(ειναι BMP εικόνα)

* Έπειτα τη συνάρτηση **rotateBMP90degrees**, η οποία δέχεται 2 αρχεία ως όρισμα(τα οποία θα προέλθουν από το stdin):
    * Ορίζει έναν πίνακα 54 θέσεων για το ελάχιστο μέγεθος του header
    * "Διαβάζει" τα πρώτα 54 στοιχεία του αρχείου από το stdin με τη χρήση της fread(). Διαβάζει σημαντικά στοιχεία απο τη κεφαλίδα:

    ```uint32_t width = *(uint32_t*)&minheader[18];```

    ```uint32_t height = *(uint32_t*)&minheader[22];```

    ```uint16_t BitsPerPixel= *(uint16_t*)&minheader[28];```

    ```uint32_t headersize = *(uint32_t*)&minheader[10];```


    * Το 18ο byte της κεφαλίδας (18 - 22) περιέχει το πλάτος της εικόνας άρα αφορά 4*8 = 32 bits αναπαράσταση του πλάτους.
    * Το 22ο byte της κεφαλίδας (22 - 26) περιέχει το ύψος της εικόνας άρα αφορά 4*8 = 32 bits αναπαράσταση του ύψους.
    * Το 28ο byte της κεφαλίδας (28 - 29) περιέχει τον αριθμό των bits ανά pixels της εικόνας άρα αφορά 2*8 = 16 bits αναπαράσταση.
    * Το 10ο byte της κεφαλίδας (10 - 14) περιέχει την αρχή των pixels της εικόνας (το offset) αρα αφορά 4*8 = 32 bits για την αναπαράσταση.
    * (Ομοίως για τα υπόλοιπα).

    - Η έκφραση (*(uint32_t*)&header[18];):  
        * Το ```&header[18]```  παίρνει τη διεύθυνση της μνήμης του 18 στοιχείου του πίνακα header.
        * Το ```(uint32_t*)``` κάνει cast τη διευθυνση μνήμης του 18ου στοιχείου του πίνακα απο δεικτη σε uint8_t σε δεικτη σε uint32_t.
        * To ```*``` στην αρχή παραπέμπει στο δείκτη που λαμβάνεται μετα το cast. Παίνει την τιμή που είναι αποθηκευμένη στη θέση μνήμης που δείχνει η διεύθυνση που υπολογίζεται ερμηνεύοντας το &header[18] ως uint32_t*. Αυτό σημαίνει ότι ερμηνεύει τα 4 byte ξεκινώντας από το 18ο byte στον πίνακα κεφαλίδων ως μια ακέραια τιμή.
        * (ομοίως για τα άλλα 2 με τη μόνη διαφορά το uint16_t στο 3ο)

    * Καλείται η συνάρτηση isValidBMP.
    * Δημιουργείται νέος πίνακας header και διαβάζονται τυχόν καινούργια στοιχεία, πέρα απο τα 54
    * Υπολογίζεται το μέγεθος της εικόνας λαμβάνοντας υπόψη το padding ως εξής: 

        * ```(4 - (originalRawSize % 4)) % 4;```: 
            * ```RawSize % 4```: Δείχνει πόσα bytes λείπουν για να είναι πολλαπλάστιο του 4 η γραμμή
            * ```4 - (originalRawSize % 4)```: Αφού γνωρίζω πόσα bytes λείπουν για να γίνει η γραμμή πολλαπλάσιο του 4,υπολογίζεται πόσα bytes πρέπει να προστεθούν για να συμπληρωθεί το padding.
            * ```(4 - (originalRawSize % 4)) % 4;```: Το τελευταίο % 4 εξασφαλίζει ότι το αποτέλεσμα θα είναι μικρότερο από 4, καθώς θέλω να βρω το πραγματικό μέγεθος του padding για μια γραμμή που πρέπει να είναι πολλαπλάσιο του 4.



    * Δημιουργείται ο πίνακας pixels που θα αποθηκεύσει τα pixels της εικόνας. Ορίζεται το νέο υψος, πλάτος και μέγεθος της ανεστραμμένης εικόνας και γίνεται η περιστροφή με τη χρήση 2 for loops.(Κάθε pixel της εικόνας αναπαριστάται απο 3 θέσεις στον πίνακα, μία για κάθε ένα απο τα 3 χρώματα RGB).
    * Καλείται η **isValidBMP()**, για έλεγχο της ανεστραμμένης εικόνας.
    * Mεταφέρονται τα νέα δεδομένα(header,otherdata, pixels) στο καινούργιο αρχείο.

* Στη main καλείται η συνάρτηση για περιστροφή της εικόνας με ορίσματα: stdin, stdout, γιατι από εκεί δέχεται το πρόγραμμα τα αρχεία με ανακατεύθυνση.
