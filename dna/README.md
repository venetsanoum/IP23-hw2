> Για την επίλυση της άσκησης 2: **DNA**

* Η συνάρτηση **isValid** δέχεται έναν χαρακτήρα και επιστρέφει τη τιμή αληθείας της συνθήκης ```(c == 'A' || c == 'T' || c == 'G' || c == 'C')```. Ουσιαστικά ελέγχει αν ένας χαρακτήρας είναι βάση.

* Η συνάρτηση **LoadFile** χρησιμοποιείται για να ανοίξει, να διαβάσει ένα αρχείο και να δημιουργήσει έναν πίνακα ο οποίος θα περιέχει όλα τα έγκυρα στοιχεία της αλυσίδας και έπειτα να κλείσει το αρχείο. Συγκεκριμένα:
    - Ανοίγει το αρχείο path που δέχεται σαν όρισμα με την εντολή fopen(για ανάγνωση: r).
    - Γίνεται χρήση της fseek για να βρεθεί το μέγεθος του αρχείου δηλαδή το μέγεθος της αλυσίδας DNA. Αρχικά μετεφέρεται ο file pointer στο τέλος (SEEK_END), με την ftell παίρνω το μέγεθος του αρχείου και επανατοποθετώ το file pointer στην αρχή (SEEK_SET).
    - Δεσμεύεται δυναμικά ο πίνακας buffer που θα αποθηκεύσει την αλυσίδα του αρχείου και γίνεται έλεγχος επιτυχίας της malloc.
    - Ορίζεται μια μεταβλητή currentChar στην οποία θα αποθηκεύεται κάθε φορά μέχρι το τέλος του αρχείου(EOF) ένας χαρακτήρας από το αρχείο ο οποίος λαμβάνεται με τη χρήση της fgetc(). 
    - Όσο δεν έχει τελειώσει το αρχείο ελέγχεται αν ο χαρακτήρας είναι έγκυρος με τη κλήση της isValid και αποθηκεύεται στο buffer.
    - Τοποθετείται ο τερματικός χαρακτήρας, κλείνει το αρχείο με fclose και επιστρέφεται ο πίνακας με την αλυσίδα DNA που θα περέχει μόνο βάσεις και όχι extra χαρακτήρες.

* Η συνάρτηση **CommonSubStr** χρησιμοποιείται για να βρει τη μέγιστη κοινή αλυσίδα μεταξύ 2 αλυσίδων.
    * Διασχίζονται και οι 2 πίνακες με 2 εμφωλευμένα for loops και με ένα while loop, το οποίο εκτελείται όσο δεν είμαστε στο τέλος κάποιας εκ των δύο αλυσίδων και υπάρχει ταύτιση των στοιχείων. Μετράω το μήκος της κοινής ακολουθίας τους και αυξάνω τις θέσεις στους πίνακες(x, y) ωστε να ελέγξω τα επόμενα στοιχεία και να βρω διαδοχικά κοινά στοιχεία. Πριν το while loop το x παίρνει τη τιμή του i και το y του j ώστε να αναζητηθούν κοινές αλυσίδες με αρχικό σημείο όλα τα στοιχεία και των δύο πινάκων. 
    * Έξω από το while loop ανανεώνεται η μέγιστη κοινή αλυσίδα αν χρειάζεται(αν currentLength > maxCommonChain). Για τη μέγιστη αλυσίδα(μέχρι εκείνη τη στιγμή) φτιάχνω μια μεταβλητή end η οποία θα δείχνει τη θέση του τελευταίου στοιχείου της κοινής αλυσίδας.
    * Έξω απο τα for και το while loop,ελέγχεται αν βρέθηκε κοινή αλυσίδα(maxCommonChain == 0 σημαίνει πως δεν βρέθηκε), φτιαχνω άλλη μία μεταβλητή start που θα δείχνει τη θέση του πρώτου στοιχείου της κοινής αλυσίδας και εν συνεχεία διασχίζω αυτό το κομμάτι του πίνακα(από start εως end) που περιέχει τη μέγιστη κοινή αλυσίδα και εκτυπώνω τους χαρακήρες έναν-έναν.

* Στη **main**:
    * Ελέγχεται αν τα ορίσματα στη γραμμή εντολών είναι 3(argc != 3) και αν δεν είναι το πρόγραμμα τερματίζει.
    * Καλείται η συνάρτηση **LoadFile** για τα δύο αρχεία(ορίσματα).
    * Με τη χρήση της strlen επιστρέφεται το μέγεθος των δύο αλυσίδων(ο αριθμός των χαρακτήρων που περιέχουν)
    * Ελέγχεται αν ξεπερνάτε ο μέγιστος αριθμός βάσεων που είναι αποδεκτός.
    * Καλείται η **CommonSubStr** για την εύρεση της μέγιστης κοινής αλυσίδας.
    * Τελικά αποδεσμεύονται οι δύο πίνακες που δεσμεύτηκαν δυναμικά με τη **LoadFile**.